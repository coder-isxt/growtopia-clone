window.GTModules = window.GTModules || {};

window.GTModules.draw = (function createDrawModule() {
  function createController(options) {
    const opts = options || {};
    const scopeBacking = {};
    const scope = new Proxy(scopeBacking, {
      has() {
        return true;
      },
      get(target, prop) {
        if (prop === Symbol.unscopables) return undefined;
        if (Object.prototype.hasOwnProperty.call(target, prop)) {
          return target[prop];
        }
        return globalThis[prop];
      },
      set(target, prop, value) {
        target[prop] = value;
        return true;
      }
    });

    function syncScope() {
      if (typeof opts.sync === "function") {
        opts.sync(scopeBacking);
      }
    }

    const DRAW_IMPL = "      function drawBackground() {\n        const viewW = getCameraViewWidth();\n        const viewH = getCameraViewHeight();\n        const weatherImageUrl = getActiveWeatherImageUrl();\n        if (weatherImageUrl) {\n          const weatherImg = getBlockImageByPath(weatherImageUrl);\n          if (weatherImg) {\n            const sx = weatherImg.naturalWidth || weatherImg.width || 1;\n            const sy = weatherImg.naturalHeight || weatherImg.height || 1;\n            const scale = Math.max(viewW / sx, viewH / sy);\n            const drawW = sx * scale;\n            const drawH = sy * scale;\n            const drawX = (viewW - drawW) * 0.5;\n            const drawY = (viewH - drawH) * 0.5;\n            ctx.save();\n            ctx.imageSmoothingEnabled = true;\n            ctx.drawImage(weatherImg, drawX, drawY, drawW, drawH);\n            ctx.fillStyle = \"rgba(11, 24, 38, 0.1)\";\n            ctx.fillRect(0, 0, viewW, viewH);\n            ctx.restore();\n            return;\n          }\n        }\n        const t = performance.now() * 0.00008;\n        const cloudShift = Math.sin(t) * 30;\n\n        ctx.fillStyle = \"#8fd9ff\";\n        ctx.fillRect(0, 0, viewW, viewH);\n\n        ctx.fillStyle = \"rgba(255,255,255,0.55)\";\n        for (let i = 0; i \u003c 8; i++) {\n          const x = ((i * 180 + cloudShift * (i % 2 ? 1 : -1)) % (viewW + 220)) - 110;\n          const y = 40 + (i % 3) * 48;\n          ctx.beginPath();\n          ctx.ellipse(x, y, 55, 20, 0, 0, Math.PI * 2);\n          ctx.fill();\n        }\n\n        ctx.fillStyle = \"#78c16a\";\n        ctx.fillRect(0, viewH - 46, viewW, 46);\n      }\n\n      function drawAllDamageOverlays() {\n        if (tileDamageByKey.size === 0) return;\n        \n        const viewW = getCameraViewWidth();\n        const viewH = getCameraViewHeight();\n        const startX = Math.floor(cameraX / TILE);\n        const endX = Math.ceil((cameraX + viewW) / TILE);\n        const startY = Math.floor(cameraY / TILE);\n        const endY = Math.ceil((cameraY + viewH) / TILE);\n\n        tileDamageByKey.forEach((damage, key) =\u003e {\n          if (!damage || !damage.hits) return;\n          const parts = key.split(\"_\");\n          const tx = parseInt(parts[0], 10);\n          const ty = parseInt(parts[1], 10);\n          \n          if (tx \u003c startX || tx \u003e endX || ty \u003c startY || ty \u003e endY) return;\n          \n          const id = world[ty] \u0026\u0026 world[ty][tx];\n          if (!id) return;\n          const durability = getBlockDurability(id);\n          if (!Number.isFinite(durability) || durability \u003c= 1) return;\n          \n          const ratio = Math.max(0, Math.min(1, damage.hits / durability));\n          if (ratio \u003c= 0) return;\n          \n          const x = tx * TILE - cameraX;\n          const y = ty * TILE - cameraY;\n          const stage = Math.max(1, Math.min(4, Math.ceil(ratio * 4)));\n          const alpha = 0.22 + stage * 0.14;\n          const crackColor = \"rgba(245, 251, 255, \" + alpha.toFixed(3) + \")\";\n          const seed = ((tx * 73856093) ^ (ty * 19349663) ^ (id * 83492791)) \u003e\u003e\u003e 0;\n          \n          ctx.save();\n          ctx.strokeStyle = crackColor;\n          ctx.lineWidth = 1;\n          ctx.beginPath();\n          const lineCount = 2 + stage * 2;\n          for (let i = 0; i \u003c lineCount; i++) {\n            const a = ((seed + i * 137) % 1000) / 1000;\n            const b = ((seed + i * 241 + 71) % 1000) / 1000;\n            const c = ((seed + i * 389 + 19) % 1000) / 1000;\n            const d = ((seed + i * 521 + 43) % 1000) / 1000;\n            const x1 = x + 1 + a * (TILE - 2);\n            const y1 = y + 1 + b * (TILE - 2);\n            const x2 = x + 1 + c * (TILE - 2);\n            const y2 = y + 1 + d * (TILE - 2);\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n          }\n          ctx.stroke();\n          ctx.restore();\n        });\n      }\n\n      function drawWorld() {\n        const viewW = getCameraViewWidth();\n        const viewH = getCameraViewHeight();\n        const startX = Math.floor(cameraX / TILE);\n        const endX = Math.ceil((cameraX + viewW) / TILE);\n        const startY = Math.floor(cameraY / TILE);\n        const endY = Math.ceil((cameraY + viewH) / TILE);\n\n        // const //drawBlockDamageOverlay = (tx, ty, id, x, y) =\u003e {\n        //   if (!id) return;\n        //   const durability = getBlockDurability(id);\n        //   if (!Number.isFinite(durability) || durability \u003c= 1) return;\n        //   const damage = getTileDamage(tx, ty);\n        //   if (!damage.hits) return;\n        //   const ratio = Math.max(0, Math.min(1, damage.hits / durability));\n        //   if (ratio \u003c= 0) return;\n        //   const stage = Math.max(1, Math.min(4, Math.ceil(ratio * 4)));\n        //   const alpha = 0.22 + stage * 0.14;\n        //   const crackColor = \"rgba(245, 251, 255, \" + alpha.toFixed(3) + \")\";\n        //   const seed = ((tx * 73856093) ^ (ty * 19349663) ^ (id * 83492791)) \u003e\u003e\u003e 0;\n        //   ctx.save();\n        //   ctx.strokeStyle = crackColor;\n        //   ctx.lineWidth = 1;\n        //   ctx.beginPath();\n        //   const lineCount = 2 + stage * 2;\n        //   for (let i = 0; i \u003c lineCount; i++) {\n        //     const a = ((seed + i * 137) % 1000) / 1000;\n        //     const b = ((seed + i * 241 + 71) % 1000) / 1000;\n        //     const c = ((seed + i * 389 + 19) % 1000) / 1000;\n        //     const d = ((seed + i * 521 + 43) % 1000) / 1000;\n        //     const x1 = x + 1 + a * (TILE - 2);\n        //     const y1 = y + 1 + b * (TILE - 2);\n        //     const x2 = x + 1 + c * (TILE - 2);\n        //     const y2 = y + 1 + d * (TILE - 2);\n        //     ctx.moveTo(x1, y1);\n        //     ctx.lineTo(x2, y2);\n        //   }\n        //   ctx.stroke();\n        //   ctx.restore();\n        // };\n\n        for (let ty = startY; ty \u003c= endY; ty++) {\n          if (ty \u003c 0 || ty \u003e= WORLD_H) continue;\n          for (let tx = startX; tx \u003c= endX; tx++) {\n            if (tx \u003c 0 || tx \u003e= WORLD_W) continue;\n            const id = world[ty][tx];\n            if (!id) continue;\n\n            const x = tx * TILE - cameraX;\n            const y = ty * TILE - cameraY;\n            const def = blockDefs[id];\n            if (!def) continue;\n\n            if (id === PLATFORM_ID) {\n              if (drawBlockImage(def, x, y)) {\n                //drawBlockDamageOverlay(tx, ty, id, x, y);\n                continue;\n              }\n              ctx.fillStyle = \"#6d4f35\";\n              ctx.fillRect(x, y + 2, TILE, 6);\n              ctx.fillStyle = \"rgba(255, 238, 202, 0.25)\";\n              ctx.fillRect(x + 1, y + 2, TILE - 2, 2);\n              //drawBlockDamageOverlay(tx, ty, id, x, y);\n              continue;\n            }\n\n            if (STAIR_ROTATION_IDS.includes(id)) {\n              if (drawStairImage(id, def, x, y)) {\n                //drawBlockDamageOverlay(tx, ty, id, x, y);\n                continue;\n              }\n              ctx.fillStyle = def.color;\n              ctx.beginPath();\n              if (id === 13) {\n                ctx.moveTo(x, y);\n                ctx.lineTo(x, y + TILE);\n                ctx.lineTo(x + TILE, y + TILE);\n              } else if (id === 14) {\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + TILE, y);\n                ctx.lineTo(x, y + TILE);\n              } else if (id === 15) {\n                ctx.moveTo(x, y + TILE);\n                ctx.lineTo(x + TILE, y + TILE);\n                ctx.lineTo(x + TILE, y);\n              } else {\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + TILE, y);\n                ctx.lineTo(x + TILE, y + TILE);\n              }\n              ctx.closePath();\n              ctx.fill();\n              ctx.fillStyle = \"rgba(255,255,255,0.11)\";\n              ctx.fillRect(x + 2, y + 2, TILE - 4, 4);\n              //drawBlockDamageOverlay(tx, ty, id, x, y);\n              continue;\n            }\n\n            if (SPIKE_ROTATION_IDS.includes(id)) {\n              if (drawSpikeImage(id, def, x, y)) {\n                //drawBlockDamageOverlay(tx, ty, id, x, y);\n                continue;\n              }\n              ctx.fillStyle = def.color || \"#8d9aae\";\n              const spikeIdx = SPIKE_ROTATION_IDS.indexOf(id);\n              const spikeAngle = spikeIdx \u003e= 0 ? (spikeIdx * Math.PI / 2) : 0;\n              ctx.save();\n              ctx.translate(x + TILE * 0.5, y + TILE * 0.5);\n              if (spikeAngle !== 0) ctx.rotate(spikeAngle);\n              ctx.beginPath();\n              ctx.moveTo(-TILE * 0.5, TILE * 0.5);\n              ctx.lineTo(-TILE * 0.5, -TILE * 0.5);\n              ctx.lineTo(TILE * 0.5, TILE * 0.5);\n              ctx.closePath();\n              ctx.fill();\n              ctx.restore();\n              //drawBlockDamageOverlay(tx, ty, id, x, y);\n              continue;\n            }\n\n            if (isPlantSeedBlockId(id)) {\n              drawTreePlant(tx, ty, x, y);\n              //drawBlockDamageOverlay(tx, ty, id, x, y);\n              continue;\n            }\n\n            if (id === DISPLAY_BLOCK_ID) {\n              ctx.fillStyle = def.color || \"#314154\";\n              ctx.fillRect(x, y, TILE, TILE);\n              ctx.strokeStyle = \"rgba(255,255,255,0.95)\";\n              ctx.lineWidth = 1;\n              ctx.strokeRect(x + 0.5, y + 0.5, TILE - 1, TILE - 1);\n              ctx.strokeStyle = \"rgba(255,255,255,0.45)\";\n              ctx.strokeRect(x + 2.5, y + 2.5, TILE - 5, TILE - 5);\n\n              const displayItem = getLocalDisplayItem(tx, ty);\n              if (displayItem) {\n                if (displayItem.type === \"cosmetic\") {\n                  let drawnCosmetic = false;\n                  for (let i = 0; i \u003c COSMETIC_ITEMS.length; i++) {\n                    const item = COSMETIC_ITEMS[i];\n                    if (!item || item.id !== displayItem.cosmeticId) continue;\n                    drawnCosmetic = drawCosmeticSprite(item, x + 4, y + 4, TILE - 8, TILE - 8, 1);\n                    if (!drawnCosmetic) {\n                      ctx.fillStyle = item.color || \"#9bb4ff\";\n                      ctx.fillRect(x + 5, y + 5, TILE - 10, TILE - 10);\n                    }\n                    break;\n                  }\n                } else {\n                  const displayDef = blockDefs[displayItem.blockId];\n                  const displayImg = getBlockImage(displayDef);\n                  if (displayImg) {\n                    ctx.save();\n                    ctx.imageSmoothingEnabled = false;\n                    ctx.drawImage(displayImg, x + 4, y + 4, TILE - 8, TILE - 8);\n                    ctx.restore();\n                  } else {\n                    ctx.fillStyle = (displayDef \u0026\u0026 displayDef.color) ? displayDef.color : \"#cfd8e5\";\n                    ctx.fillRect(x + 5, y + 5, TILE - 10, TILE - 10);\n                  }\n                }\n              }\n              //drawBlockDamageOverlay(tx, ty, id, x, y);\n              continue;\n            }\n\n            if (id === SIGN_ID \u0026\u0026 drawBlockImage(def, x, y)) {\n              //drawBlockDamageOverlay(tx, ty, id, x, y);\n              continue;\n            }\n\n            if (id === VENDING_ID) {\n              if (drawBlockImage(def, x, y)) {\n                //drawBlockDamageOverlay(tx, ty, id, x, y);\n                drawVendingWorldLabel(tx, ty, x, y);\n                continue;\n              }\n              ctx.fillStyle = \"#4d6b8b\";\n              ctx.fillRect(x, y, TILE, TILE);\n              ctx.fillStyle = \"rgba(255,255,255,0.12)\";\n              ctx.fillRect(x + 3, y + 3, TILE - 6, 8);\n              ctx.fillStyle = \"#9cd8ff\";\n              ctx.fillRect(x + 6, y + 14, TILE - 12, 10);\n              ctx.fillStyle = \"#ffd166\";\n              ctx.fillRect(x + TILE - 10, y + 6, 4, 4);\n              //drawBlockDamageOverlay(tx, ty, id, x, y);\n              drawVendingWorldLabel(tx, ty, x, y);\n              continue;\n            }\n\n            if (id === WATER_ID \u0026\u0026 drawAnimatedWater(def, x, y, tx, ty)) {\n              //drawBlockDamageOverlay(tx, ty, id, x, y);\n              continue;\n            }\n\n            if (drawBlockImage(def, x, y)) {\n              //drawBlockDamageOverlay(tx, ty, id, x, y);\n              continue;\n            }\n\n            ctx.fillStyle = def.color;\n            ctx.fillRect(x, y, TILE, TILE);\n            if (def.liquid) {\n              const wave = Math.sin((performance.now() * 0.01) + tx * 0.7 + ty * 0.4) * 1.6;\n              ctx.fillStyle = \"rgba(210, 245, 255, 0.3)\";\n              ctx.fillRect(x + 1, y + 3 + wave, TILE - 2, 4);\n              ctx.fillStyle = \"rgba(18, 84, 170, 0.2)\";\n              ctx.fillRect(x, y + TILE - 4, TILE, 4);\n            } else {\n              ctx.fillStyle = \"rgba(255,255,255,0.08)\";\n              ctx.fillRect(x + 2, y + 2, TILE - 4, 6);\n              ctx.fillStyle = \"rgba(0,0,0,0.14)\";\n              ctx.fillRect(x, y + TILE - 5, TILE, 5);\n            }\n            //drawBlockDamageOverlay(tx, ty, id, x, y);\n          }\n        }\n      }\n\n      function drawBlockImageInWorld(def, x, y)\n      {\n        const DROP_RENDER_SCALE = 0.65;\n        const img = getBlockImage(def);\n        if (!img) return false;\n        ctx.save();\n        ctx.imageSmoothingEnabled = false;\n        const size = TILE * DROP_RENDER_SCALE;\n        const offset = (TILE - size) / 2;\n        ctx.drawImage(img, x + offset, y + offset, size, size);\n        ctx.restore();\n        return true;\n      }\n\n      function drawWorldDrops() {\n        if (!worldDrops.size) return;\n        const viewW = getCameraViewWidth();\n        const viewH = getCameraViewHeight();\n        const now = performance.now();\n        \n        worldDrops.forEach((drop) =\u003e {\n          if (!drop) return;\n          const x = drop.x - cameraX;\n          const y = drop.y - cameraY + Math.sin((now + drop.id.length * 91) * 0.005) * 1.5;\n          if (x \u003c -TILE || y \u003c -TILE || x \u003e viewW + TILE || y \u003e viewH + TILE) return;\n          if (drop.type === \"tool\") {\n            ctx.save();\n            ctx.fillStyle = drop.toolId === TOOL_WRENCH ? \"#89a4b4\" : \"#c59b81\";\n            ctx.fillRect(x, y, TILE, TILE);\n            ctx.strokeStyle = \"rgba(0,0,0,0.35)\";\n            ctx.strokeRect(x + 0.5, y + 0.5, TILE - 1, TILE - 1);\n            ctx.fillStyle = \"rgba(12,20,30,0.8)\";\n            ctx.font = \"bold 11px \u0027Trebuchet MS\u0027, sans-serif\";\n            ctx.fillText(drop.toolId === TOOL_WRENCH ? \"W\" : \"F\", x + 7, y + 12);\n            ctx.restore();\n          } else if (drop.type === \"block\") {\n            const def = blockDefs[drop.blockId];\n\n            if (def \u0026\u0026 drawBlockImageInWorld(def, x, y)) {\n              // draw count badge\n            } else {\n              ctx.save();\n              ctx.fillStyle = def \u0026\u0026 def.color ? def.color : \"#a0a0a0\";\n              const size = TILE * 0.65;\n              const offset = (TILE - size) / 2;\n              ctx.fillRect(x + offset, y + offset, size, size);\n              ctx.restore();\n            }\n          } else {\n            let drawn = false;\n            for (let i = 0; i \u003c COSMETIC_ITEMS.length; i++) {\n              const item = COSMETIC_ITEMS[i];\n              if (!item || item.id !== drop.cosmeticId) continue;\n              drawn = drawCosmeticSprite(item, x + 2, y + 2, TILE - 4, TILE - 4, 1);\n              if (!drawn) {\n                ctx.save();\n                ctx.fillStyle = item.color || \"#9bb4ff\";\n                const size = TILE * 0.65;\n                const offset = (TILE - size) / 2;\n\n                ctx.fillRect(x + offset, y + offset, size, size);\n                ctx.restore();\n              }\n              break;\n            }\n          }\n          if (drop.amount \u003e 1) {\n            ctx.save();\n            ctx.font = \"11px \u0027Trebuchet MS\u0027, sans-serif\";\n            const label = \"x\" + drop.amount;\n            const labelW = ctx.measureText(label).width + 8;\n            ctx.fillStyle = \"rgba(8, 22, 34, 0.85)\";\n            ctx.fillRect(x + TILE - labelW - 1, y + TILE - 14, labelW, 13);\n            ctx.strokeStyle = \"rgba(255, 255, 255, 0.24)\";\n            ctx.strokeRect(x + TILE - labelW - 1, y + TILE - 14, labelW, 13);\n            ctx.fillStyle = \"#f7fbff\";\n            ctx.fillText(label, x + TILE - labelW + 3, y + TILE - 4);\n            ctx.restore();\n          }\n        });\n      }\n\n      function drawSignTopText() {\n        const ctrl = getSignController();\n        if (!ctrl || typeof ctrl.drawTopText !== \"function\") return;\n        ctrl.drawTopText(ctx);\n      }\n\n      function getCosmeticImage(item) {\n        if (!item || !item.imagePath) return null;\n        const key = String(item.imagePath);\n        if (!cosmeticImageCache.has(key)) {\n          const img = new Image();\n          img.decoding = \"async\";\n          img.src = key;\n          cosmeticImageCache.set(key, img);\n        }\n        const img = cosmeticImageCache.get(key);\n        if (!img || !img.complete || img.naturalWidth \u003c= 0 || img.naturalHeight \u003c= 0) return null;\n        return img;\n      }\n\n      function getBlockImage(def) {\n        if (!def || !def.imagePath) return null;\n        const key = String(def.imagePath);\n        if (!blockImageCache.has(key)) {\n          const img = new Image();\n          img.decoding = \"async\";\n          img.src = key;\n          blockImageCache.set(key, img);\n        }\n        const img = blockImageCache.get(key);\n        if (!img || !img.complete || img.naturalWidth \u003c= 0 || img.naturalHeight \u003c= 0) return null;\n        return img;\n      }\n\n      function getBlockImageByPath(path) {\n        const key = String(path || \"\").trim();\n        if (!key) return null;\n        if (!blockImageCache.has(key)) {\n          const img = new Image();\n          img.decoding = \"async\";\n          img.src = key;\n          blockImageCache.set(key, img);\n        }\n        const img = blockImageCache.get(key);\n        if (!img || !img.complete || img.naturalWidth \u003c= 0 || img.naturalHeight \u003c= 0) return null;\n        return img;\n      }\n\n      function buildWaterFramePaths(def) {\n        if (!def || !def.imagePath) return [];\n        const explicit = Array.isArray(SETTINGS.WATER_FRAME_PATHS)\n          ? SETTINGS.WATER_FRAME_PATHS.map((x) =\u003e String(x || \"\").trim()).filter(Boolean)\n          : [];\n        if (explicit.length \u003e= 4) {\n          return explicit.slice(0, 4);\n        }\n        const base = String(def.imagePath).trim();\n        const extIdx = base.lastIndexOf(\".\");\n        const hasExt = extIdx \u003e 0;\n        const stem = hasExt ? base.slice(0, extIdx) : base;\n        const ext = hasExt ? base.slice(extIdx) : \"\";\n        const underscored = [1, 2, 3, 4].map((i) =\u003e stem + \"_\" + i + ext);\n        const numbered = [1, 2, 3, 4].map((i) =\u003e stem + i + ext);\n        const candidates = [];\n        for (const p of underscored.concat(numbered)) {\n          if (!candidates.includes(p) \u0026\u0026 p !== base) candidates.push(p);\n        }\n        return candidates.slice(0, 8);\n      }\n\n      function getWaterFrameImages(def) {\n        if (!waterFramePathCache.length) {\n          const paths = buildWaterFramePaths(def);\n          for (const p of paths) waterFramePathCache.push(p);\n        }\n        const ready = [];\n        for (const p of waterFramePathCache) {\n          const img = getBlockImageByPath(p);\n          if (img) ready.push(img);\n          if (ready.length \u003e= 4) break;\n        }\n        return ready;\n      }\n\n      function drawAnimatedWater(def, x, y, tx, ty) {\n        const frames = getWaterFrameImages(def);\n        if (!frames.length) return false;\n        if (frames.length === 1) {\n          ctx.save();\n          ctx.imageSmoothingEnabled = false;\n          ctx.drawImage(frames[0], x, y, TILE, TILE);\n          ctx.restore();\n          return true;\n        }\n        const now = performance.now();\n        const phaseOffset = ((tx * 31 + ty * 17) % 997) / 997;\n        const animPos = ((now / WATER_FRAME_MS) + phaseOffset) % frames.length;\n        const i0 = Math.floor(animPos) % frames.length;\n        const i1 = (i0 + 1) % frames.length;\n        const blend = animPos - Math.floor(animPos);\n        ctx.save();\n        ctx.imageSmoothingEnabled = false;\n        ctx.globalAlpha = 1 - blend;\n        ctx.drawImage(frames[i0], x, y, TILE, TILE);\n        ctx.globalAlpha = blend;\n        ctx.drawImage(frames[i1], x, y, TILE, TILE);\n        ctx.restore();\n        return true;\n      }\n\n      function getVendingWorldLabel(tx, ty) {\n        const ctrl = getVendingController();\n        if (!ctrl || typeof ctrl.getLocal !== \"function\") return \"\";\n        const vm = ctrl.getLocal(tx, ty);\n        if (!vm) return \"\";\n        const qty = Math.max(1, Math.floor(Number(vm.sellQuantity) || 1));\n        const price = Math.max(0, Math.floor(Number(vm.priceLocks) || 0));\n        let itemName = \"\";\n        if (String(vm.sellType || \"\") === \"cosmetic\") {\n          const cosmeticId = String(vm.sellCosmeticId || \"\").trim();\n          let cosmeticItem = null;\n          if (cosmeticId) {\n            for (let i = 0; i \u003c COSMETIC_ITEMS.length; i++) {\n              const item = COSMETIC_ITEMS[i];\n              if (item \u0026\u0026 item.id === cosmeticId) {\n                cosmeticItem = item;\n                break;\n              }\n            }\n          }\n          itemName = cosmeticItem \u0026\u0026 cosmeticItem.name ? cosmeticItem.name : cosmeticId;\n        } else {\n          const blockId = Math.max(0, Math.floor(Number(vm.sellBlockId) || 0));\n          const itemDef = blockDefs[blockId];\n          itemName = itemDef \u0026\u0026 itemDef.name ? itemDef.name : \"\";\n        }\n        if (!itemName || price \u003c= 0) return \"Unconfigured\";\n        return itemName + \" x\" + qty + \" / \" + price + \" WL\";\n      }\n\n      function drawVendingWorldLabel(tx, ty, x, y) {\n        const label = getVendingWorldLabel(tx, ty);\n        if (!label) return;\n        const playerTx = Math.floor((player.x + PLAYER_W / 2) / TILE);\n        const playerTy = Math.floor((player.y + PLAYER_H / 2) / TILE);\n        if (playerTx !== tx || playerTy !== ty) return;\n        ctx.save();\n        ctx.font = \"10px \u0027Trebuchet MS\u0027, sans-serif\";\n        const maxWidth = 138;\n        const lines = wrapChatText(label, maxWidth - 8).slice(0, 2);\n        let textW = 0;\n        for (let i = 0; i \u003c lines.length; i++) {\n          textW = Math.max(textW, ctx.measureText(lines[i]).width);\n        }\n        const bubbleW = Math.max(52, Math.min(maxWidth, Math.ceil(textW) + 8));\n        const bubbleH = lines.length * 12 + 6;\n        let bx = x + Math.floor((TILE - bubbleW) / 2);\n        const by = y - bubbleH - 4;\n        const viewW = getCameraViewWidth();\n        if (bx \u003c 4) bx = 4;\n        if (bx + bubbleW \u003e viewW - 4) bx = viewW - 4 - bubbleW;\n        ctx.fillStyle = \"rgba(8, 22, 34, 0.86)\";\n        ctx.fillRect(bx, by, bubbleW, bubbleH);\n        ctx.strokeStyle = \"rgba(255,255,255,0.26)\";\n        ctx.strokeRect(bx + 0.5, by + 0.5, bubbleW - 1, bubbleH - 1);\n        ctx.fillStyle = \"#f4fbff\";\n        for (let i = 0; i \u003c lines.length; i++) {\n          ctx.fillText(lines[i], bx + 4, by + 11 + i * 12);\n        }\n        ctx.restore();\n      }\n\n      function drawBlockImage(def, x, y) {\n        const img = getBlockImage(def);\n        if (!img) return false;\n        ctx.save();\n        ctx.imageSmoothingEnabled = false;\n        ctx.drawImage(img, x, y, TILE, TILE);\n        ctx.restore();\n        return true;\n      }\n\n      function drawStairImage(id, def, x, y) {\n        const baseDef = blockDefs[STAIR_BASE_ID] || def;\n        const img = getBlockImage(baseDef) || getBlockImage(def);\n        if (!img) return false;\n        // Base orientation is NW (id 13). Rotated stairs mirror this texture.\n        ctx.save();\n        ctx.imageSmoothingEnabled = false;\n        ctx.translate(x + TILE * 0.5, y + TILE * 0.5);\n        if (id === 14) {\n          ctx.scale(-1, 1);\n        } else if (id === 15) {\n          ctx.scale(-1, -1);\n        } else if (id === 16) {\n          ctx.scale(1, -1);\n        }\n        ctx.drawImage(img, -TILE * 0.5, -TILE * 0.5, TILE, TILE);\n        ctx.restore();\n        return true;\n      }\n\n      function drawSpikeImage(id, def, x, y) {\n        const baseDef = blockDefs[SPIKE_BASE_ID] || def;\n        const img = getBlockImage(baseDef) || getBlockImage(def);\n        if (!img) return false;\n        const idx = SPIKE_ROTATION_IDS.indexOf(id);\n        const angle = idx \u003e= 0 ? (idx * Math.PI / 2) : 0;\n        ctx.save();\n        ctx.imageSmoothingEnabled = false;\n        ctx.translate(x + TILE * 0.5, y + TILE * 0.5);\n        if (angle !== 0) ctx.rotate(angle);\n        ctx.drawImage(img, -TILE * 0.5, -TILE * 0.5, TILE, TILE);\n        ctx.restore();\n        return true;\n      }\n\n      function drawTreePlant(tx, ty, x, y) {\n        const ctrl = getPlantsController();\n        if (!ctrl || typeof ctrl.drawTree !== \"function\") return;\n        ctrl.drawTree(ctx, tx, ty, x, y, TILE);\n        const plant = getLocalTreePlant(tx, ty);\n        if (!plant || typeof ctrl.getGrowthState !== \"function\") return;\n        const growth = ctrl.getGrowthState(plant);\n        if (!growth) return;\n        const fruitCount = resolvePlantFruitAmount(plant);\n        const fruitBlockId = Math.max(1, Math.floor(Number(plant.yieldBlockId) || TREE_YIELD_BLOCK_ID));\n        const fruitDef = blockDefs[fruitBlockId] || null;\n        if (growth.mature) {\n          const cols = 3;\n          const rows = Math.ceil(fruitCount / cols);\n          const cell = 8;\n          const gap = 2;\n          const gridW = cols * cell + (cols - 1) * gap;\n          const gridH = rows * cell + (rows - 1) * gap;\n          const label = \"x\" + fruitCount;\n          ctx.save();\n          ctx.font = \"bold 11px \u0027Trebuchet MS\u0027, sans-serif\";\n          const labelW = Math.ceil(ctx.measureText(label).width);\n          const boxW = Math.max(gridW + 8, labelW + 10);\n          const boxH = gridH + 22;\n          let bx = x + Math.floor((TILE - boxW) / 2);\n          const by = y - boxH - 8;\n          const viewW = getCameraViewWidth();\n          if (bx \u003c 4) bx = 4;\n          if (bx + boxW \u003e viewW - 4) bx = viewW - 4 - boxW;\n          ctx.fillStyle = \"rgba(8, 22, 34, 0.9)\";\n          ctx.fillRect(bx, by, boxW, boxH);\n          ctx.strokeStyle = \"rgba(255,255,255,0.35)\";\n          ctx.strokeRect(bx + 0.5, by + 0.5, boxW - 1, boxH - 1);\n          ctx.fillStyle = \"#f7fbff\";\n          ctx.fillText(label, bx + Math.floor((boxW - labelW) / 2), by + 11);\n          const gx = bx + Math.floor((boxW - gridW) / 2);\n          const gy = by + 14;\n          for (let i = 0; i \u003c fruitCount; i++) {\n            const cx = i % cols;\n            const cy = Math.floor(i / cols);\n            const px = gx + cx * (cell + gap);\n            const py = gy + cy * (cell + gap);\n            ctx.fillStyle = fruitDef \u0026\u0026 fruitDef.color ? fruitDef.color : \"#67c95a\";\n            ctx.fillRect(px, py, cell, cell);\n            ctx.strokeStyle = \"rgba(255,255,255,0.35)\";\n            ctx.strokeRect(px + 0.5, py + 0.5, cell - 1, cell - 1);\n          }\n          ctx.restore();\n          return;\n        }\n        const playerTx = Math.floor((player.x + PLAYER_W / 2) / TILE);\n        const playerTy = Math.floor((player.y + PLAYER_H / 2) / TILE);\n        if (playerTx !== tx || playerTy !== ty) return;\n        const growMs = Math.max(1, Math.floor(Number(plant.growMs) || TREE_GROW_MS));\n        const plantedAt = Math.max(0, Math.floor(Number(plant.plantedAt) || 0));\n        const remainingMs = Math.max(0, (plantedAt + growMs) - Date.now());\n        const remainingSec = Math.max(0, Math.ceil(remainingMs / 1000));\n        const label = \"Grow: \" + remainingSec + \"s\";\n        ctx.save();\n        ctx.font = \"11px \u0027Trebuchet MS\u0027, sans-serif\";\n        const w = Math.ceil(ctx.measureText(label).width) + 10;\n        const h = 15;\n        let bx = x + Math.floor((TILE - w) / 2);\n        const by = y - h - 4;\n        const viewW = getCameraViewWidth();\n        if (bx \u003c 4) bx = 4;\n        if (bx + w \u003e viewW - 4) bx = viewW - 4 - w;\n        ctx.fillStyle = \"rgba(8, 22, 34, 0.88)\";\n        ctx.fillRect(bx, by, w, h);\n        ctx.strokeStyle = \"rgba(255,255,255,0.28)\";\n        ctx.strokeRect(bx + 0.5, by + 0.5, w - 1, h - 1);\n        ctx.fillStyle = \"#f7fbff\";\n        ctx.fillText(label, bx + 5, by + 11);\n        ctx.restore();\n      }\n\n      function drawCosmeticSprite(item, x, y, w, h, facing, opts) {\n        const img = getCosmeticImage(item);\n        if (!img) return false;\n        const options = opts \u0026\u0026 typeof opts === \"object\" ? opts : {};\n        const mode = options.mode === \"fill\" ? \"fill\" : \"contain\";\n        const alignX = Math.max(0, Math.min(1, Number(options.alignX)));\n        const alignY = Math.max(0, Math.min(1, Number(options.alignY)));\n        const useAlignX = Number.isFinite(alignX) ? alignX : 0.5;\n        const useAlignY = Number.isFinite(alignY) ? alignY : 0.5;\n        let drawX = x;\n        let drawY = y;\n        let drawW = w;\n        let drawH = h;\n        if (mode === \"contain\") {\n          const iw = Math.max(1, img.naturalWidth || 1);\n          const ih = Math.max(1, img.naturalHeight || 1);\n          const scale = Math.min(w / iw, h / ih);\n          drawW = Math.max(1, iw * scale);\n          drawH = Math.max(1, ih * scale);\n          drawX = x + (w - drawW) * useAlignX;\n          drawY = y + (h - drawH) * useAlignY;\n        }\n        ctx.save();\n        ctx.imageSmoothingEnabled = false;\n        if (facing === -1) {\n          const pivot = drawX + drawW / 2;\n          ctx.translate(pivot, 0);\n          ctx.scale(-1, 1);\n          ctx.translate(-pivot, 0);\n        }\n        ctx.drawImage(img, drawX, drawY, drawW, drawH);\n        ctx.restore();\n        return true;\n      }\n\n\n      // COSMETICS\n      function drawWings(px, py, wingsId, facing, wingFlap, wingOpen) {\n        if (!wingsId) return;\n        const item = COSMETIC_LOOKUP.wings[wingsId];\n        if (!item) return;\n        const flap = Number(wingFlap) || 0;\n        const open = Math.max(0, Math.min(1, Number(wingOpen) || 0));\n        const upStroke = Math.max(0, -flap);\n        const downStroke = Math.max(0, flap);\n        // Strong hinge-style flap: quick downstroke + lighter upstroke.\n        const flapStroke = (downStroke * 1.2) - (upStroke * 0.8);\n        const wingImg = getCosmeticImage(item);\n        if (wingImg) {\n          const centerX = px + PLAYER_W / 2;\n          const centerY = py + 17.5;\n          const baseAngle = 0.2 + open * 0.34;\n          const wingH = 19;\n          const wingW = Math.max(10, Math.round(wingH * (wingImg.naturalWidth / Math.max(1, wingImg.naturalHeight))));\n          const offsetX = Number(item \u0026\u0026 item.offsetX);\n          const offsetY = Number(item \u0026\u0026 item.offsetY);\n          const useOffsetX = Number.isFinite(offsetX) ? offsetX : 3;\n          const useOffsetY = Number.isFinite(offsetY) ? offsetY : 0;\n          const drawWingSide = (sideSign) =\u003e {\n            const angle = (sideSign * baseAngle) - (sideSign * flapStroke * 1.2);\n            ctx.save();\n            ctx.translate(centerX + sideSign * (1.5 + useOffsetX), centerY + useOffsetY);\n            ctx.rotate(angle);\n            if (sideSign \u003c 0) ctx.scale(-1, 1);\n            // Wing sprite attach point is left edge of image.\n            ctx.drawImage(wingImg, 0, -wingH / 2, wingW, wingH);\n            ctx.restore();\n          };\n          drawWingSide(-1);\n          drawWingSide(1);\n          return;\n        }\n        ctx.fillStyle = item.color;\n        const centerX = px + PLAYER_W / 2;\n        const centerY = py + 17.5;\n        const forwardSign = facing === 1 ? 1 : -1;\n        const drawWing = (sideSign) =\u003e {\n          const dir = sideSign * forwardSign;\n          const base = (0.24 + open * 0.34) * sideSign;\n          const angle = base - (sideSign * flapStroke);\n          ctx.save();\n          ctx.translate(centerX, centerY);\n          ctx.rotate(angle);\n          ctx.beginPath();\n          ctx.moveTo(0, 0);\n          ctx.lineTo(16 * dir, -7);\n          ctx.lineTo(23 * dir, 2);\n          ctx.lineTo(17 * dir, 11);\n          ctx.lineTo(4 * dir, 9);\n          ctx.closePath();\n          ctx.fill();\n          ctx.restore();\n        };\n        drawWing(-1);\n        drawWing(1);\n      }\n\n      function drawShirt(px, py, shirtId) {\n        if (!shirtId) return;\n        const item = COSMETIC_LOOKUP.shirts \u0026\u0026 COSMETIC_LOOKUP.shirts[shirtId];\n        if (!item) return;\n        if (drawCosmeticSprite(item, px + 5, py + 11, PLAYER_W - 10, 12, 1, { mode: \"contain\", alignX: 0.5, alignY: 0.5 })) {\n          return;\n        }\n        ctx.fillStyle = item.color;\n        ctx.fillRect(px + 5, py + 12, PLAYER_W - 10, 10);\n      }\n\n      function drawPants(px, py, pantsId) {\n        if (!pantsId) return;\n        const item = COSMETIC_LOOKUP.pants \u0026\u0026 COSMETIC_LOOKUP.pants[pantsId];\n        if (!item) return;\n        if (drawCosmeticSprite(item, px + 5, py + 21, PLAYER_W - 10, 8, 1, { mode: \"contain\", alignX: 0.5, alignY: 0.5 })) {\n          return;\n        }\n        ctx.fillStyle = item.color || \"#7e92a3\";\n        ctx.fillRect(px + 6, py + 22, 4, 7);\n        ctx.fillRect(px + PLAYER_W - 10, py + 22, 4, 7);\n      }\n\n      function drawShoes(px, py, shoesId, facing) {\n        if (!shoesId) return;\n        const item = COSMETIC_LOOKUP.shoes \u0026\u0026 COSMETIC_LOOKUP.shoes[shoesId];\n        if (!item) return;\n        const leftX = px + 5;\n        const rightX = px + PLAYER_W - 9;\n        const shoeY = py + 26;\n        const shoeW = 6;\n        const shoeH = 4;\n        const facingSign = facing === -1 ? -1 : 1;\n        const drewLeft = drawCosmeticSprite(item, leftX, shoeY, shoeW, shoeH, facingSign, { mode: \"contain\", alignX: 0.5, alignY: 1 });\n        const drewRight = drawCosmeticSprite(item, rightX, shoeY, shoeW, shoeH, facingSign, { mode: \"contain\", alignX: 0.5, alignY: 1 });\n        if (drewLeft || drewRight) return;\n        ctx.fillStyle = item.color || \"#5f5f6a\";\n        ctx.fillRect(leftX + 1, shoeY + 1, shoeW - 1, shoeH - 1);\n        ctx.fillRect(rightX + 1, shoeY + 1, shoeW - 1, shoeH - 1);\n      }\n\n      function drawHat(px, py, hatId, facing) {\n        if (!hatId) return;\n        const item = COSMETIC_LOOKUP.hats \u0026\u0026 COSMETIC_LOOKUP.hats[hatId];\n        if (!item) return;\n        const hatBoxX = px - 2;\n        const hatBoxY = py - 11;\n        const hatBoxW = PLAYER_W + 4;\n        const hatBoxH = 12;\n        if (drawCosmeticSprite(item, hatBoxX, hatBoxY, hatBoxW, hatBoxH, facing === -1 ? -1 : 1, { mode: \"contain\", alignX: 0.5, alignY: 1 })) {\n          return;\n        }\n        ctx.fillStyle = item.color || \"#d7c7a3\";\n        ctx.fillRect(px + 3, py - 2, PLAYER_W - 6, 2);\n      }\n\n      function drawSword(px, py, swordId, facing, swordSwing, hitDirectionY, hitStrength) {\n        if (!swordId) return;\n        const item = COSMETIC_LOOKUP.swords[swordId];\n        if (!item) return;\n        \n        const pivotX = facing === 1 ? (px + PLAYER_W - 5 + 1.5) : (px + 2 + 1.5);\n        const pivotY = py + 13 + 1;\n        let handX, handY, angle;\n\n        if (Number(hitStrength) \u003e 0) {\n          const targetRotation = facing * (-Math.PI / 2 + (Number(hitDirectionY) || 0) * Math.PI / 4);\n          const rotation = targetRotation * Number(hitStrength);\n          handX = pivotX - Math.sin(rotation) * 7;\n          handY = pivotY + Math.cos(rotation) * 7;\n          angle = (Number(hitDirectionY) || 0) * (Math.PI / 4) * Number(hitStrength);\n        } else {\n          const facingSign = facing === 1 ? 1 : -1;\n          const swing = (Number(swordSwing) || 0) * facingSign;\n          const armSwing = Math.max(-4, Math.min(4, swing * 0.18));\n          handX = facing === 1 ? (px + PLAYER_W - 3) : (px + 3);\n          handY = py + 19 + armSwing;\n          const baseAngle = 0;\n          const slash = Math.max(-1.2, Math.min(1.2, swing * 0.12));\n          angle = baseAngle + slash;\n        }\n        \n        const bladeW = 12;\n        const bladeH = 8;\n\n        ctx.save();\n        ctx.translate(handX, handY);\n        if (facing === -1) ctx.scale(-1, 1);\n        ctx.rotate(angle);\n        const img = getCosmeticImage(item);\n        if (img) {\n          ctx.imageSmoothingEnabled = false;\n          ctx.drawImage(img, 0, -bladeH / 2, bladeW, bladeH);\n          ctx.restore();\n          return;\n        }\n        ctx.fillStyle = item.color;\n        ctx.fillRect(0, -1.5, 9, 3);\n        ctx.fillStyle = \"rgba(255,255,255,0.65)\";\n        ctx.fillRect(6, -1, 4, 2);\n        ctx.restore();\n      }\n      // CHARACTER\n      function drawHumanoid(px, py, facing, bodyColor, skinColor, eyeColor, shirtId, pantsId, shoesId, hatId, pose, lookX, lookY) {\n        function fillChamferRect(x, y, w, h, color) {\n          const rx = Math.round(x);\n          const ry = Math.round(y);\n          const rw = Math.max(2, Math.round(w));\n          const rh = Math.max(2, Math.round(h));\n          ctx.fillStyle = color;\n          if (rw \u003c= 3 || rh \u003c= 3) {\n            ctx.fillRect(rx, ry, rw, rh);\n            return;\n          }\n          ctx.fillRect(rx + 1, ry, rw - 2, 1);\n          ctx.fillRect(rx, ry + 1, rw, rh - 2);\n          ctx.fillRect(rx + 1, ry + rh - 1, rw - 2, 1);\n        }\n\n        const armSwing = Number(pose \u0026\u0026 pose.armSwing) || 0;\n        const legSwing = Number(pose \u0026\u0026 pose.legSwing) || 0;\n        const hitStrength = Math.max(0, Math.min(1, Number(pose \u0026\u0026 pose.hitStrength) || 0));\n        const hitMode = String(pose \u0026\u0026 pose.hitMode || \"\");\n        const hitDirectionY = Number(pose \u0026\u0026 pose.hitDirectionY) || 0;\n        let leftArmY = py + 13 + Math.round(-armSwing * 0.6);\n        let rightArmY = py + 13 + Math.round(armSwing * 0.6);\n        const leftLegY = py + 23 + Math.round(-legSwing * 0.75);\n        const rightLegY = py + 23 + Math.round(legSwing * 0.75);\n        const faceTilt = facing === 1 ? 1 : -1;\n\n        // Growtopia-like blocky proportions.\n        const headX = px + 2;\n        const headY = py;\n        const headW = PLAYER_W - 4;\n        const headH = 12;\n        const torsoX = px + 5;\n        const torsoY = py + 12;\n        const torsoW = PLAYER_W - 10;\n        const torsoH = 8;\n\n        fillChamferRect(headX, headY, headW, headH, skinColor);\n        fillChamferRect(torsoX, torsoY, torsoW, torsoH, skinColor);\n        let leftArmX = px + 2;\n        let rightArmX = px + PLAYER_W - 5;\n        if (hitStrength \u003e 0) {\n          const forward = Math.round((hitMode === \"fist\" ? 4 : 2) * hitStrength) * (facing === 1 ? 1 : -1);\n          if (facing === 1) {\n            rightArmX += forward;\n          } else {\n            leftArmX += forward;\n          }\n        }\n\n        const drawArmRect = (x, y, isAttackArm) =\u003e {\n          if (hitStrength \u003e 0 \u0026\u0026 isAttackArm) {\n            const pivotX = x + 1.5;\n            const pivotY = y + 1;\n            const targetRotation = facing * (-Math.PI / 2 + (hitDirectionY * Math.PI / 4));\n            const rotation = targetRotation * hitStrength;\n            ctx.save();\n            ctx.translate(pivotX, pivotY);\n            ctx.rotate(rotation);\n            ctx.translate(-pivotX, -pivotY);\n            fillChamferRect(x, y, 3, 8, skinColor);\n            if (hitMode === \"fist\" \u0026\u0026 hitStrength \u003e 0.05) {\n              const fistY = y + 5;\n              const fistX = facing === 1 ? (x + 2) : (x - 2);\n              fillChamferRect(fistX, fistY, 3, 3, skinColor);\n            }\n            ctx.restore();\n          } else {\n            fillChamferRect(x, y, 3, 8, skinColor);\n          }\n        };\n\n        drawArmRect(leftArmX, leftArmY, facing === -1);\n        drawArmRect(rightArmX, rightArmY, facing === 1);\n\n        fillChamferRect(px + 6, leftLegY, 4, 7, skinColor);\n        fillChamferRect(px + PLAYER_W - 10, rightLegY, 4, 7, skinColor);\n\n        drawShirt(px, py, shirtId);\n        drawPants(px, py, pantsId);\n        drawShoes(px, py, shoesId, facing);\n        drawHat(px, py, hatId, facing);\n\n        ctx.fillStyle = \"rgba(0,0,0,0.14)\";\n        ctx.fillRect(headX + 1, headY + 1, headW - 2, 1);\n        ctx.fillRect(torsoX + 1, torsoY - 1, torsoW - 2, 1);\n        ctx.fillRect(torsoX + 1, torsoY + torsoH, torsoW - 2, 1);\n\n        // Eyes are offset by facing direction (no mouse-follow wobble).\n        const faceOffset = faceTilt \u003e 0 ? 1 : -1;\n        const leftEyeX = px + 5 + faceOffset;\n        const rightEyeX = px + PLAYER_W - 11 + faceOffset;\n        const eyeY = py + 3;\n        ctx.fillStyle = \"#f3f6ff\";\n        ctx.fillRect(leftEyeX, eyeY, 5, 4);\n        ctx.fillRect(rightEyeX, eyeY, 5, 4);\n\n        ctx.fillStyle = eyeColor;\n        const pupilOffset = faceTilt \u003e 0 ? 1 : 0;\n        ctx.fillRect(leftEyeX + 1 + pupilOffset, eyeY + 1, 2, 2);\n        ctx.fillRect(rightEyeX + 1 + pupilOffset, eyeY + 1, 2, 2);\n\n        const mouthX = px + 8 + faceOffset;\n        const mouthY = py + 9;\n        ctx.fillStyle = \"rgba(85, 52, 43, 0.95)\";\n        ctx.fillRect(mouthX, mouthY, 5, 1);\n        ctx.fillRect(mouthX + 1, mouthY + 1, 3, 1);\n\n        const noseX = faceTilt \u003e 0 ? px + 13 : px + 6;\n        ctx.fillStyle = \"rgba(124, 84, 66, 0.9)\";\n        ctx.fillRect(noseX, py + 7, 2, 2);\n\n        // Small head shading for pixel depth similar to GT style.\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.08)\";\n        if (faceTilt \u003e 0) {\n          ctx.fillRect(headX + headW - 1, headY + 1, 1, headH - 2);\n        } else {\n          ctx.fillRect(headX, headY + 1, 1, headH - 2);\n        }\n\n        return {};\n      }\n\n      function getLocalLookVector() {\n        return {\n          x: player.facing === -1 ? -0.75 : 0.75,\n          y: 0\n        };\n      }\n\n      function getRemoteLookVector(other) {\n        return {\n          x: (other \u0026\u0026 other.facing === -1) ? -0.75 : 0.75,\n          y: 0\n        };\n      }\n\n      function drawPlayer() {\n        localPlayerWrenchHitbox.length = 0;\n        const nowMs = performance.now();\n        const px = Math.round(player.x - cameraX);\n        const py = Math.round(player.y - cameraY);\n        const cosmetics = equippedCosmetics;\n        const localMotion = typeof animationsModule.sampleLocal === \"function\"\n          ? animationsModule.sampleLocal(player, nowMs)\n          : { speed: Math.abs(player.vx), vy: player.vy, grounded: player.grounded };\n        const pose = typeof animationsModule.buildPose === \"function\"\n          ? animationsModule.buildPose(localMotion, nowMs, playerId)\n          : { bodyBob: 0, bodyTilt: 0, wingFlap: 0, wingOpen: 0.24, swordSwing: 0, eyeYOffset: 0, eyeHeight: 3 };\n        if (danceUntilMs \u003e Date.now()) {\n          const danceT = nowMs * 0.015;\n          pose.bodyBob = (Number(pose.bodyBob) || 0) + Math.sin(danceT * 1.6) * 1.6;\n          pose.bodyTilt = (Number(pose.bodyTilt) || 0) + Math.sin(danceT) * 0.18;\n          pose.armSwing = (Number(pose.armSwing) || 0) + Math.sin(danceT * 2.3) * 3.6;\n          pose.legSwing = (Number(pose.legSwing) || 0) + Math.cos(danceT * 2.3) * 2.8;\n        }\n        const hitT = Math.max(0, Math.min(1, 1 - ((nowMs - lastHitAtMs) / HIT_ANIM_MS)));\n        if (hitT \u003e 0) {\n          const hitEase = hitT * hitT * (3 - 2 * hitT);\n          const facingSign = player.facing === 1 ? 1 : -1;\n          pose.bodyTilt = (Number(pose.bodyTilt) || 0) + facingSign * (0.07 * hitEase);\n          pose.hitDirectionY = lastHitDirectionY;\n          if (cosmetics.swords) {\n            pose.hitMode = \"sword\";\n            pose.hitStrength = hitEase;\n            pose.armSwing = (Number(pose.armSwing) || 0) + facingSign * (1.1 * hitEase);\n            pose.swordSwing = (Number(pose.swordSwing) || 0) + facingSign * (8.2 * hitEase);\n          } else {\n            pose.hitMode = \"fist\";\n            pose.hitStrength = hitEase;\n            pose.armSwing = (Number(pose.armSwing) || 0) + facingSign * (3.1 * hitEase);\n            pose.swordSwing = 0;\n          }\n        } else {\n          pose.hitMode = \"\";\n          pose.hitStrength = 0;\n        }\n        // Pixel-snap body baseline to avoid subpixel jitter and slight ground clipping.\n        const basePy = Math.round(py + (pose.bodyBob || 0) - 1);\n        const localWingFlap = (pose.wingFlap || 0) + getWingFlapPulse(nowMs);\n        const localWingOpen = Math.max(0, Math.min(1, Number(pose.wingOpen) || 0.24));\n\n        drawWings(px, basePy, cosmetics.wings, player.facing, localWingFlap, localWingOpen);\n\n        ctx.save();\n        ctx.translate(px + PLAYER_W / 2, basePy + PLAYER_H / 2);\n        ctx.rotate(Number(pose.bodyTilt) || 0);\n        ctx.translate(-(px + PLAYER_W / 2), -(basePy + PLAYER_H / 2));\n\n        const localLook = getLocalLookVector();\n        drawHumanoid(px, basePy, player.facing, \"#263238\", \"#b98a78\", \"#0d0d0d\", cosmetics.shirts, cosmetics.pants, cosmetics.shoes, cosmetics.hats, pose, localLook.x, localLook.y);\n\n        drawSword(px, basePy, cosmetics.swords, player.facing, pose.swordSwing || 0, pose.hitDirectionY, pose.hitStrength);\n        ctx.restore();\n        const titleDef = getEquippedTitleDef();\n        const nameText = String(playerName || \"Player\").slice(0, 20);\n        const nameY = basePy - 8;\n        ctx.font = PLAYER_NAME_FONT;\n        const localTitleName = titleDef ? formatTitleWithUsername(titleDef.name, nameText) : \"\";\n        const showLocalName = shouldShowNameAlongsideTitle(localTitleName, nameText);\n        const titleText = localTitleName ? (\"[\" + localTitleName + \"] \") : \"\";\n        const localTitleStyle = normalizeTitleStyle(titleDef \u0026\u0026 titleDef.style);\n        const titleWidth = titleText ? ctx.measureText(titleText).width : 0;\n        const nameWidth = showLocalName ? ctx.measureText(nameText).width : 0;\n        const totalWidth = titleWidth + nameWidth;\n        let cursorX = Math.round(px + PLAYER_W / 2 - totalWidth / 2);\n        if (titleDef) {\n          const titleColor = localTitleStyle.rainbow\n            ? getRainbowTitleColor(nowMs)\n            : (titleDef.color || \"#8fb4ff\");\n          ctx.fillStyle = titleColor;\n          if (localTitleStyle.bold) {\n            ctx.font = \"bold \" + PLAYER_NAME_FONT;\n          }\n          if (localTitleStyle.glow) {\n            ctx.shadowBlur = 10;\n            ctx.shadowColor = localTitleStyle.glowColor || titleColor;\n          }\n          ctx.fillText(titleText, cursorX, nameY);\n          ctx.shadowBlur = 0;\n          ctx.shadowColor = \"transparent\";\n          ctx.font = PLAYER_NAME_FONT;\n          cursorX += titleWidth;\n        }\n        if (showLocalName) {\n          ctx.fillStyle = \"#f3fbff\";\n          ctx.fillText(nameText, cursorX, nameY);\n        }\n        if (slotOrder[selectedSlot] === TOOL_WRENCH) {\n          const textWidth = (cursorX - (Math.round(px + PLAYER_W / 2 - totalWidth / 2))) + nameWidth;\n          const iconSize = 22 / cameraZoom;\n          const iconX = Math.round(px + PLAYER_W / 2 - totalWidth / 2) + textWidth + (6 / cameraZoom);\n          const iconY = nameY - (4 / cameraZoom) - (iconSize / 2);\n          drawNameWrenchIcon(iconX, iconY, iconSize);\n          localPlayerWrenchHitbox.push({\n            x: iconX,\n            y: iconY,\n            w: iconSize,\n            h: iconSize,\n            accountId: playerProfileId || \"local\",\n            name: nameText\n          });\n        }\n      }\n\n      function drawRemotePlayers() {\n        const nowMs = performance.now();\n        const nowEpoch = Date.now();\n        const viewW = getCameraViewWidth();\n        const viewH = getCameraViewHeight();\n        const keepIds = [];\n        playerWrenchHitboxes.length = 0;\n        const wrenchSelected = slotOrder[selectedSlot] === TOOL_WRENCH;\n        const visiblePlayers = [];\n        remotePlayers.forEach((other) =\u003e {\n          const otherId = (other.id || \"\").toString();\n          keepIds.push(otherId);\n          const px = Math.round(other.x - cameraX);\n          const py = Math.round(other.y - cameraY);\n          if (px \u003c -40 || py \u003c -40 || px \u003e viewW + 40 || py \u003e viewH + 40) return;\n          const distance = Math.sqrt(px * px + py * py);\n          visiblePlayers.push({ other, otherId, px, py, distance });\n        });\n        // Sort by distance and limit to 30 closest\n        visiblePlayers.sort((a, b) =\u003e a.distance - b.distance);\n        visiblePlayers.slice(0, 30).forEach(({ other, otherId, px, py }) =\u003e {\n          const cosmetics = other.cosmetics || {};\n          const remoteMotion = typeof animationsModule.sampleRemote === \"function\"\n            ? animationsModule.sampleRemote(remoteAnimationTracker, otherId, other.x, other.y, nowMs)\n            : { speed: 0, vy: 0, grounded: true };\n          const pose = typeof animationsModule.buildPose === \"function\"\n            ? animationsModule.buildPose(remoteMotion, nowMs, otherId)\n            : { bodyBob: 0, bodyTilt: 0, wingFlap: 0, wingOpen: 0.24, swordSwing: 0, eyeYOffset: 0, eyeHeight: 3 };\n          if ((Number(other.danceUntil) || 0) \u003e nowEpoch) {\n            const danceT = nowMs * 0.015;\n            pose.bodyBob = (Number(pose.bodyBob) || 0) + Math.sin(danceT * 1.6) * 1.6;\n            pose.bodyTilt = (Number(pose.bodyTilt) || 0) + Math.sin(danceT) * 0.18;\n            pose.armSwing = (Number(pose.armSwing) || 0) + Math.sin(danceT * 2.3) * 3.6;\n            pose.legSwing = (Number(pose.legSwing) || 0) + Math.cos(danceT * 2.3) * 2.8;\n          }\n          const basePy = Math.round(py + (pose.bodyBob || 0) - 1);\n\n          drawWings(px, basePy, cosmetics.wings || \"\", other.facing || 1, pose.wingFlap || 0, pose.wingOpen || 0.24);\n\n          ctx.save();\n          ctx.translate(px + PLAYER_W / 2, basePy + PLAYER_H / 2);\n          ctx.rotate(Number(pose.bodyTilt) || 0);\n          ctx.translate(-(px + PLAYER_W / 2), -(basePy + PLAYER_H / 2));\n\n          const remoteLook = getRemoteLookVector(other);\n          drawHumanoid(px, basePy, other.facing || 1, \"#2a75bb\", \"#b98a78\", \"#102338\", cosmetics.shirts || \"\", cosmetics.pants || \"\", cosmetics.shoes || \"\", cosmetics.hats || \"\", pose, remoteLook.x, remoteLook.y);\n\n          drawSword(px, basePy, cosmetics.swords || \"\", other.facing || 1, pose.swordSwing || 0, 0, 0);\n          ctx.restore();\n\n          const nameText = String(other.name || \"Player\").slice(0, 20);\n          const titleRaw = other \u0026\u0026 other.title \u0026\u0026 typeof other.title === \"object\" ? other.title : {};\n          const fallbackTitle = getTitleDef(titleRaw.id || \"\");\n          const rawRemoteTitle = String(titleRaw.name || (fallbackTitle \u0026\u0026 fallbackTitle.name) || \"\");\n          const titleName = formatTitleWithUsername(rawRemoteTitle, nameText).slice(0, 24);\n          const titleColor = String(titleRaw.color || (fallbackTitle \u0026\u0026 fallbackTitle.color) || \"#8fb4ff\").slice(0, 24);\n          const remoteTitleStyle = normalizeTitleStyle(\n            (titleRaw.style \u0026\u0026 typeof titleRaw.style === \"object\")\n              ? titleRaw.style\n              : (fallbackTitle \u0026\u0026 fallbackTitle.style)\n          );\n          const showRemoteName = shouldShowNameAlongsideTitle(titleName, nameText);\n          const nameY = basePy - 8;\n          ctx.font = PLAYER_NAME_FONT;\n          const titleText = titleName ? (\"[\" + titleName + \"] \") : \"\";\n          const titleWidth = titleText ? ctx.measureText(titleText).width : 0;\n          const nameWidth = showRemoteName ? ctx.measureText(nameText).width : 0;\n          const totalWidth = titleWidth + nameWidth;\n          const nameX = Math.round(px + PLAYER_W / 2 - totalWidth / 2);\n          let cursorX = nameX;\n          if (titleName) {\n            const styledColor = remoteTitleStyle.rainbow\n              ? getRainbowTitleColor(nowMs)\n              : (titleColor || \"#8fb4ff\");\n            ctx.fillStyle = styledColor;\n            if (remoteTitleStyle.bold) {\n              ctx.font = \"bold \" + PLAYER_NAME_FONT;\n            }\n            if (remoteTitleStyle.glow) {\n              ctx.shadowBlur = 10;\n              ctx.shadowColor = remoteTitleStyle.glowColor || styledColor;\n            }\n            ctx.fillText(titleText, cursorX, nameY);\n            ctx.shadowBlur = 0;\n            ctx.shadowColor = \"transparent\";\n            ctx.font = PLAYER_NAME_FONT;\n            cursorX += titleWidth;\n          }\n          if (showRemoteName) {\n            ctx.fillStyle = \"#f3fbff\";\n            ctx.fillText(nameText, cursorX, nameY);\n          }\n          if (wrenchSelected \u0026\u0026 other.accountId) {\n            const textWidth = (cursorX - nameX) + nameWidth;\n            const iconSize = 22 / cameraZoom;\n            const iconX = Math.round(nameX + textWidth + (6 / cameraZoom));\n            const iconY = nameY - (4 / cameraZoom) - (iconSize / 2);\n            drawNameWrenchIcon(iconX, iconY, iconSize);\n            playerWrenchHitboxes.push({\n              x: iconX,\n              y: iconY,\n              w: iconSize,\n              h: iconSize,\n              accountId: String(other.accountId || \"\"),\n              name: nameText\n            });\n          }\n        });\n        if (typeof animationsModule.pruneTracker === \"function\") {\n          animationsModule.pruneTracker(remoteAnimationTracker, keepIds);\n        }\n      }\n\n      function drawNameWrenchIcon(x, y, size) {\n        ctx.save();\n        const r = size / 2;\n        ctx.fillStyle = \"rgba(255, 209, 102, 0.95)\";\n        ctx.beginPath();\n        ctx.arc(x + r, y + r, r, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.strokeStyle = \"rgba(14, 36, 56, 0.9)\";\n        ctx.lineWidth = Math.max(1, size * 0.08);\n        ctx.stroke();\n        ctx.strokeStyle = \"rgba(14, 36, 56, 0.95)\";\n        ctx.lineWidth = Math.max(1.5, size * 0.12);\n        const pad = size * 0.25;\n        ctx.beginPath();\n        ctx.moveTo(x + pad, y + size - pad);\n        ctx.lineTo(x + size - pad, y + pad);\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.arc(x + size - pad, y + pad, size * 0.15, 0, Math.PI * 2);\n        ctx.stroke();\n        ctx.restore();\n      }\n\n      function hitWrenchNameIcon(worldX, worldY) {\n        if (!inWorld) return null;\n        for (let i = localPlayerWrenchHitbox.length - 1; i \u003e= 0; i--) {\n          const hit = localPlayerWrenchHitbox[i];\n          if (worldX \u003e= hit.x \u0026\u0026 worldX \u003c= hit.x + hit.w \u0026\u0026 worldY \u003e= hit.y \u0026\u0026 worldY \u003c= hit.y + hit.h) {\n            return hit;\n          }\n        }\n        for (let i = playerWrenchHitboxes.length - 1; i \u003e= 0; i--) {\n          const hit = playerWrenchHitboxes[i];\n          if (worldX \u003e= hit.x \u0026\u0026 worldX \u003c= hit.x + hit.w \u0026\u0026 worldY \u003e= hit.y \u0026\u0026 worldY \u003c= hit.y + hit.h) {\n            return hit;\n          }\n        }\n        return null;\n      }\n\n      function openWrenchMenuFromNameIcon(clientX, clientY) {\n        if (slotOrder[selectedSlot] !== TOOL_WRENCH) return false;\n        const point = canvasPointFromClient(clientX, clientY);\n        const hit = hitWrenchNameIcon(point.x / Math.max(0.01, cameraZoom), point.y / Math.max(0.01, cameraZoom));\n        if (!hit || !hit.accountId) return false;\n        const targetAccountId = hit.accountId === \"local\" ? (playerProfileId || \"\") : hit.accountId;\n        if (!targetAccountId) return false;\n        const friendCtrl = getFriendsController();\n        if (!friendCtrl || typeof friendCtrl.openProfileByAccount !== \"function\") return false;\n        return Boolean(friendCtrl.openProfileByAccount(targetAccountId, hit.name));\n      }\n\n      function wrapChatText(text, maxTextWidth) {\n        if (typeof drawUtilsModule.wrapTextLines === \"function\") {\n          return drawUtilsModule.wrapTextLines(ctx, text, maxTextWidth, 4);\n        }\n        const words = (text || \"\").split(/\\s+/).filter(Boolean);\n        if (!words.length) return [\"\"];\n        const lines = [];\n        let line = words[0];\n        for (let i = 1; i \u003c words.length; i++) {\n          const nextLine = line + \" \" + words[i];\n          if (ctx.measureText(nextLine).width \u003c= maxTextWidth) {\n            line = nextLine;\n          } else {\n            lines.push(line);\n            line = words[i];\n          }\n        }\n        lines.push(line);\n        return lines.slice(0, 4);\n      }\n\n      function drawAllOverheadChats() {\n        const localPx = player.x - cameraX;\n        const localPy = player.y - cameraY;\n        drawOverheadChat(playerId, localPx + PLAYER_W / 2, localPy - 10);\n        remotePlayers.forEach((other) =\u003e {\n          const px = other.x - cameraX;\n          const py = other.y - cameraY;\n          drawOverheadChat(other.id || \"\", px + PLAYER_W / 2, py - 28);\n        });\n      }\n\n      function drawOverheadChat(sourcePlayerId, centerX, baseY) {\n        if (!sourcePlayerId) return;\n        const entry = overheadChatByPlayer.get(sourcePlayerId);\n        if (!entry) return;\n\n        const now = performance.now();\n        const remaining = entry.expiresAt - now;\n        if (remaining \u003c= 0) {\n          overheadChatByPlayer.delete(sourcePlayerId);\n          return;\n        }\n\n        let alpha = 1;\n        const fadeStart = CHAT_BUBBLE_FADE_MS;\n        if (remaining \u003c= fadeStart) {\n          const t = Math.max(0, Math.min(1, remaining / fadeStart));\n          // Smooth fade-out (ease-out cubic) during final 1.5s.\n          alpha = t * t * (3 - 2 * t);\n        }\n        const text = entry.text;\n        if (typeof drawUtilsModule.drawOverheadBubble === \"function\") {\n          drawUtilsModule.drawOverheadBubble(ctx, {\n            centerX,\n            baseY,\n            text,\n            alpha,\n            maxWidth: CHAT_BUBBLE_MAX_WIDTH,\n            lineHeight: CHAT_BUBBLE_LINE_HEIGHT,\n            viewWidth: getCameraViewWidth(),\n            font: \"12px \u0027Trebuchet MS\u0027, sans-serif\"\n          });\n          return;\n        }\n        ctx.save();\n        ctx.globalAlpha = alpha;\n        ctx.font = \"12px \u0027Trebuchet MS\u0027, sans-serif\";\n        const padX = 7;\n        const padY = 5;\n        const maxTextWidth = CHAT_BUBBLE_MAX_WIDTH - padX * 2;\n        const lines = wrapChatText(text, maxTextWidth);\n        let widestLine = 0;\n        for (const line of lines) {\n          widestLine = Math.max(widestLine, ctx.measureText(line).width);\n        }\n        const bubbleW = Math.min(CHAT_BUBBLE_MAX_WIDTH, Math.max(36, widestLine + padX * 2));\n        const bubbleH = lines.length * CHAT_BUBBLE_LINE_HEIGHT + padY * 2;\n        let bubbleX = centerX - bubbleW / 2;\n        let bubbleY = baseY - bubbleH - 2;\n        if (bubbleX \u003c 4) bubbleX = 4;\n        const viewW = getCameraViewWidth();\n        if (bubbleX + bubbleW \u003e viewW - 4) bubbleX = viewW - 4 - bubbleW;\n        if (bubbleY \u003c 4) bubbleY = 4;\n        ctx.fillStyle = \"rgba(10, 25, 40, 0.92)\";\n        ctx.fillRect(bubbleX, bubbleY, bubbleW, bubbleH);\n        ctx.strokeStyle = \"rgba(255, 255, 255, 0.28)\";\n        ctx.strokeRect(bubbleX, bubbleY, bubbleW, bubbleH);\n        ctx.fillStyle = \"#f7fbff\";\n        for (let i = 0; i \u003c lines.length; i++) {\n          ctx.fillText(lines[i], bubbleX + padX, bubbleY + padY + 10 + i * CHAT_BUBBLE_LINE_HEIGHT);\n        }\n        ctx.restore();\n      }\n\n      function drawCrosshair() {\n        const selectedId = slotOrder[selectedSlot];\n        if (selectedId === TOOL_FIST || selectedId === TOOL_WRENCH) return;\n        if (typeof selectedId !== \"number\") return;\n\n        const reachTiles = Math.max(1, getEditReachTiles());\n        const centerTx = Math.floor((player.x + PLAYER_W / 2) / TILE);\n        const centerTy = Math.floor((player.y + PLAYER_H / 2) / TILE);\n        const minTx = Math.max(0, centerTx - Math.ceil(reachTiles));\n        const maxTx = Math.min(WORLD_W - 1, centerTx + Math.ceil(reachTiles));\n        const minTy = Math.max(0, centerTy - Math.ceil(reachTiles));\n        const maxTy = Math.min(WORLD_H - 1, centerTy + Math.ceil(reachTiles));\n\n        ctx.save();\n        ctx.strokeStyle = \"rgba(255, 209, 102, 0.26)\";\n        ctx.lineWidth = 1;\n        for (let ty = minTy; ty \u003c= maxTy; ty++) {\n          for (let tx = minTx; tx \u003c= maxTx; tx++) {\n            if (!canEditTarget(tx, ty)) continue;\n            const x = tx * TILE - cameraX;\n            const y = ty * TILE - cameraY;\n            ctx.strokeRect(x + 0.5, y + 0.5, TILE - 1, TILE - 1);\n          }\n        }\n        ctx.restore();\n      }\n\n      function drawInfo() {\n        const tx = Math.floor((player.x + PLAYER_W / 2) / TILE);\n        const ty = Math.floor((player.y + PLAYER_H / 2) / TILE);\n        const selectedId = slotOrder[selectedSlot];\n        const usingFist = selectedId === TOOL_FIST;\n        const usingWrench = selectedId === TOOL_WRENCH;\n        const usingTool = usingFist || usingWrench;\n        const itemName = usingFist ? \"Fist\" : (usingWrench ? \"Wrench\" : blockDefs[selectedId].name);\n        const countText = usingTool ? \"infinite\" : String(inventory[selectedId]);\n        let cosmeticOwned = 0;\n        for (const item of COSMETIC_ITEMS) {\n          cosmeticOwned += Math.max(0, Number(cosmeticInventory[item.id]) || 0);\n        }\n\n        ctx.fillStyle = \"rgba(9, 25, 41, 0.7)\";\n        ctx.fillRect(12, 12, 390, 62);\n        ctx.strokeStyle = \"rgba(255,255,255,0.25)\";\n        ctx.strokeRect(12, 12, 390, 62);\n\n        ctx.fillStyle = \"#f7fbff\";\n        ctx.font = \"bold 15px \u0027Trebuchet MS\u0027, sans-serif\";\n        ctx.fillText(\"World: \" + currentWorldId + \" | Selected: \" + itemName + \" (\" + countText + \")\", 24, 36);\n        ctx.font = \"14px \u0027Trebuchet MS\u0027, sans-serif\";\n        ctx.fillText(\"Player Tile: \" + tx + \", \" + ty + \" | Cosmetic items: \" + cosmeticOwned, 24, 56);\n      }\n\n      function render() {\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.setTransform(cameraZoom, 0, 0, cameraZoom, 0, 0);\n        drawBackground();\n        drawWorld();\n        drawAllDamageOverlays(); // ADDED HERE\n        if (particleController \u0026\u0026 typeof particleController.draw === \"function\") {\n          particleController.draw(ctx, cameraX, cameraY);\n        }\n        drawWorldDrops();\n        drawRemotePlayers();\n        drawPlayer();\n        drawAllOverheadChats();\n        drawCrosshair();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        drawSignTopText();\n      }";
    const setupInScope = new Function(
      "scope",
      "with (scope) {\n" + DRAW_IMPL + "\n" +
      "scope.__render = render;\n" +
      "scope.__openWrenchMenuFromNameIcon = openWrenchMenuFromNameIcon;\n" +
      "scope.__wrapChatText = wrapChatText;\n" +
      "}"
    );

    syncScope();
    setupInScope(scopeBacking);

    let renderFn = typeof scopeBacking.__render === "function"
      ? scopeBacking.__render
      : function noopRender() {};
    let openWrenchMenuFromNameIconFn = typeof scopeBacking.__openWrenchMenuFromNameIcon === "function"
      ? scopeBacking.__openWrenchMenuFromNameIcon
      : function noopWrench() { return false; };
    let wrapChatTextFn = typeof scopeBacking.__wrapChatText === "function"
      ? scopeBacking.__wrapChatText
      : function fallbackWrap(text) { return [String(text || "")]; };

    return {
      render: function renderFrame() {
        syncScope();
        return renderFn();
      },
      openWrenchMenuFromNameIcon: function openWrench(clientX, clientY) {
        syncScope();
        return Boolean(openWrenchMenuFromNameIconFn(clientX, clientY));
      },
      wrapChatText: function wrapText(text, maxTextWidth) {
        syncScope();
        return wrapChatTextFn(text, maxTextWidth);
      }
    };
  }

  return {
    createController
  };
})();


